name: Sequential PR Automerger

on:
  workflow_dispatch: # Allows manual triggering
  schedule:
    - cron: '*/10 * * * *' # Runs every 10 minutes (reduced from every 1 minute to avoid rate limiting)

# Ensures only one instance of this workflow runs at a time for this group.
# If a run is in progress, new scheduled triggers will be skipped until it completes.
concurrency:
  group: ${{ github.workflow }}-merger
  cancel-in-progress: false # Let the current merging process finish

permissions:
  contents: write # To merge branches and delete branches
  pull-requests: write # To merge PRs and interact with them

jobs:
  automerge:
    runs-on: ubuntu-latest
    env:
      # --- CONFIGURATION ---
      GH_TOKEN: ${{ secrets.GITHUB_TOKEN }} # Provided by GitHub Actions
      BASE_BRANCH: 'master' # The branch PRs should target to be considered for merging
      MERGE_METHOD: 'SQUASH' # MERGE, SQUASH, or REBASE
      DELETE_BRANCH_AFTER_MERGE: 'true' # 'true' or 'false'
      # Optional: Only merge PRs with this label. Leave empty to disable.
      REQUIRED_LABEL: 'automerge' # e.g., 'ready-to-merge' or 'automerge'
      # --- END CONFIGURATION ---

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Required for gh cli to work properly with branches

      - name: Get Default Branch if BASE_BRANCH is not set (or to verify)
        if: env.BASE_BRANCH == '' # Or if you want to dynamically fetch it
        run: |
          DEFAULT_BRANCH=$(gh repo view --json defaultBranchRef --jq '.defaultBranchRef.name')
          echo "DEFAULT_BRANCH_NAME=${DEFAULT_BRANCH}" >> $GITHUB_ENV
          echo "Using default branch: $DEFAULT_BRANCH"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }} # gh cli needs token

      - name: Set Base Branch to Use
        run: |
          BRANCH_TO_USE="${{ env.BASE_BRANCH }}"
          if [ -z "$BRANCH_TO_USE" ]; then
            BRANCH_TO_USE="${{ env.DEFAULT_BRANCH_NAME }}"
          fi
          echo "BASE_BRANCH_EFFECTIVE=${BRANCH_TO_USE}" >> $GITHUB_ENV
          echo "Will process PRs targeting: ${BRANCH_TO_USE}"

      - name: Fetch Mergeable PRs
        id: get_prs
        run: |
          echo "Fetching PRs targeting ${{ env.BASE_BRANCH_EFFECTIVE }}..."
          
          # Special handling for Snyk PRs
          echo "Checking for Snyk PRs with titles like '[Snyk] Security upgrade ...'"
          
          # Get detailed PR data
          PR_DATA=$(gh pr list \
            --state open \
            --base "${{ env.BASE_BRANCH_EFFECTIVE }}" \
            --limit 100 \
            --json "number,title,headRefName,author,isDraft,mergeable,mergeStateStatus,reviewDecision,labels")
          
          echo "Example PR data:"
          echo "$PR_DATA" | jq '.[0]'
          
          # Create the filter query based on conditions - more carefully constructed
          FILTER_SCRIPT='
            .[] | 
            select(
              .isDraft == false
              and (.labels | length > 0)
          '
          
          # Add label filter if required
          if [ -n "${{ env.REQUIRED_LABEL }}" ]; then
            echo "Filtering for label: ${{ env.REQUIRED_LABEL }}"
            FILTER_SCRIPT="${FILTER_SCRIPT} and (
              .labels | map(.name) | index(\"${{ env.REQUIRED_LABEL }}\")
            )"
          fi
          
          # Add Snyk detection filter
          FILTER_SCRIPT="${FILTER_SCRIPT} and (
            (.title | startswith(\"[Snyk] Security upgrade\"))
          )"
          
          # Close the filter and get the number
          FILTER_SCRIPT="${FILTER_SCRIPT}) | .number"
          
          echo "Using JQ filter script: $FILTER_SCRIPT"
          
          # Apply the filter
          PR_NUMBERS=$(echo "$PR_DATA" | jq -r "$FILTER_SCRIPT" | tr '\n' ' ')
          
          # Output the results
          if [ -z "$PR_NUMBERS" ] || [ "$PR_NUMBERS" = "null" ]; then
            echo "No Snyk security upgrade PRs found."
            echo "PR_NUMBERS_TO_MERGE=" >> $GITHUB_OUTPUT
          else
            echo "Found Snyk security upgrade PRs to merge (numbers): $PR_NUMBERS"
            echo "PR_NUMBERS_TO_MERGE=$PR_NUMBERS" >> $GITHUB_OUTPUT
          fi
          
          # Simple debugging counters
          echo "Debug counts:"
          echo "Total open PRs: $(echo "$PR_DATA" | jq 'length')"
          echo "Non-draft PRs: $(echo "$PR_DATA" | jq 'map(select(.isDraft == false)) | length')"
          echo "PRs with title '[Snyk] Security upgrade': $(echo "$PR_DATA" | jq 'map(select(.title | startswith("[Snyk] Security upgrade"))) | length')"
          if [ -n "${{ env.REQUIRED_LABEL }}" ]; then
            echo "PRs with required label '${{ env.REQUIRED_LABEL }}': $(echo "$PR_DATA" | jq 'map(select(.labels | map(.name) | index("${{ env.REQUIRED_LABEL }}"))) | length')"
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Merge PRs Sequentially
        if: steps.get_prs.outputs.PR_NUMBERS_TO_MERGE != ''
        run: |
          echo "Attempting to merge PRs: ${{ steps.get_prs.outputs.PR_NUMBERS_TO_MERGE }}"
          
          # Build merge command arguments
          MERGE_ARGS=""
          if [ "${{ env.DELETE_BRANCH_AFTER_MERGE }}" == "true" ]; then
            MERGE_ARGS="$MERGE_ARGS --delete-branch"
          fi

          case "${{ env.MERGE_METHOD }}" in
            SQUASH)
              MERGE_ARGS="$MERGE_ARGS --squash"
              ;;
            REBASE)
              MERGE_ARGS="$MERGE_ARGS --rebase"
              ;;
            MERGE)
              MERGE_ARGS="$MERGE_ARGS --merge"
              ;;
            *)
              echo "Invalid MERGE_METHOD: ${{ env.MERGE_METHOD }}. Using default (merge commit)."
              MERGE_ARGS="$MERGE_ARGS --merge"
              ;;
          esac
          
          # Create a file to track merged and failed PRs
          echo "# Snyk Security Upgrade Merge Report $(date)" > merge_report.md
          echo "" >> merge_report.md
          echo "| PR # | Status | Security Upgrade | Reason |" >> merge_report.md
          echo "|------|--------|-----------------|--------|" >> merge_report.md
          
          for pr_number in ${{ steps.get_prs.outputs.PR_NUMBERS_TO_MERGE }}; do
            # Get PR details
            PR_DETAILS=$(gh pr view $pr_number --json number,title,headRefName,url)
            
            TITLE=$(echo "$PR_DETAILS" | jq -r '.title')
            HEAD_BRANCH=$(echo "$PR_DETAILS" | jq -r '.headRefName')
            PR_URL=$(echo "$PR_DETAILS" | jq -r '.url')
            
            # Extract package upgrade info for better reporting
            if [[ "$TITLE" =~ \[Snyk\]\ Security\ upgrade\ ([a-zA-Z0-9\-_\.\/]+)\ from\ ([0-9\.]+)\ to\ ([0-9\.]+) ]]; then
              PACKAGE="${BASH_REMATCH[1]}"
              FROM_VERSION="${BASH_REMATCH[2]}"
              TO_VERSION="${BASH_REMATCH[3]}"
              UPGRADE_INFO="$PACKAGE $FROM_VERSION → $TO_VERSION"
            else
              UPGRADE_INFO="$TITLE"
            fi
            
            echo "🔒 Processing security upgrade PR #$pr_number: $UPGRADE_INFO"
            echo "Branch: $HEAD_BRANCH"
            echo "URL: $PR_URL"
            
            # First attempt: Default merge method
            echo "1️⃣ Attempt 1: Using ${{ env.MERGE_METHOD }} method..."
            if gh pr merge $pr_number $MERGE_ARGS --admin; then
              echo "✅ Successfully merged security PR #$pr_number"
              echo "| $pr_number | ✅ Success | $UPGRADE_INFO | First attempt |" >> merge_report.md
              sleep 5
              continue
            fi
            
            # Second attempt: Try with auto flag for conflict resolution
            echo "2️⃣ Attempt 2: Adding --auto flag to resolve conflicts..."
            if gh pr merge $pr_number $MERGE_ARGS --admin --auto; then
              echo "✅ Successfully auto-resolved conflicts for PR #$pr_number"
              echo "| $pr_number | ✅ Success | $UPGRADE_INFO | Auto-resolved conflicts |" >> merge_report.md
              sleep 5
              continue
            fi
            
            # Third attempt: Make sure required label is present
            if [ -n "${{ env.REQUIRED_LABEL }}" ]; then
              echo "3️⃣ Attempt 3: Adding '${{ env.REQUIRED_LABEL }}' label and trying again..."
              gh pr edit $pr_number --add-label "${{ env.REQUIRED_LABEL }}"
              if gh pr merge $pr_number $MERGE_ARGS --admin --auto; then
                echo "✅ Successfully merged PR #$pr_number after adding label"
                echo "| $pr_number | ✅ Success | $UPGRADE_INFO | Added label |" >> merge_report.md
                sleep 5
                continue
              fi
            fi
            
            # Fourth attempt: Try different merge method (merge instead of squash or rebase)
            if [ "${{ env.MERGE_METHOD }}" != "MERGE" ]; then
              echo "4️⃣ Attempt 4: Switching to merge commit method..."
              if gh pr merge $pr_number --merge --admin --auto; then
                echo "✅ Successfully merged PR #$pr_number with merge commit method"
                echo "| $pr_number | ✅ Success | $UPGRADE_INFO | Used merge commit |" >> merge_report.md
                sleep 5
                continue
              fi
            fi
            
            # If all attempts failed, record the failure and error message
            echo "❌ All merge attempts failed for PR #$pr_number"
            
            # Get the specific error message
            ERROR_OUTPUT=$(gh pr merge $pr_number --admin 2>&1 || true)
            echo "Error: $ERROR_OUTPUT"
            
            # Extract branch info for manual resolution instructions
            BASE_BRANCH="${{ env.BASE_BRANCH_EFFECTIVE }}"
            
            echo "| $pr_number | ❌ Failed | $UPGRADE_INFO | See instructions below |" >> merge_report.md
            echo "" >> merge_report.md
            echo "### PR #$pr_number: $TITLE" >> merge_report.md
            echo "**Error:** \`$ERROR_OUTPUT\`" >> merge_report.md
            echo "" >> merge_report.md
            echo "To resolve conflicts manually:" >> merge_report.md
            echo "```bash" >> merge_report.md
            echo "gh pr checkout $pr_number" >> merge_report.md
            echo "git fetch origin $BASE_BRANCH" >> merge_report.md
            echo "git merge origin/$BASE_BRANCH" >> merge_report.md
            echo "# Resolve conflicts, then:" >> merge_report.md
            echo "git add ." >> merge_report.md
            echo "git commit -m \"Resolved conflicts for Snyk PR #$pr_number\"" >> merge_report.md
            echo "git push" >> merge_report.md
            echo "```" >> merge_report.md
            echo "" >> merge_report.md
            
            # Wait before moving to next PR
            sleep 5
          done
          
          echo "All Snyk security PRs processed."
          echo "Final report:"
          cat merge_report.md
          
          # Create an issue with merge results if any PRs failed
          if grep -q "❌ Failed" merge_report.md; then
            echo "Creating issue with merge report for failed security upgrades..."
            gh issue create --title "⚠️ Snyk Security Upgrades Needing Attention: $(date +%Y-%m-%d)" \
                          --body-file merge_report.md \
                          --label "security,needs-attention"
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: No PRs to merge
        if: steps.get_prs.outputs.PR_NUMBERS_TO_MERGE == ''
        run: echo "No PRs met the criteria for merging at this time."
