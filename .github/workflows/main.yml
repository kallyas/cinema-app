name: Sequential PR Automerger

on:
  workflow_dispatch: # Allows manual triggering
  schedule:
    - cron: '*/10 * * * *' # Runs every 10 minutes (reduced from every 1 minute to avoid rate limiting)

# Ensures only one instance of this workflow runs at a time for this group.
# If a run is in progress, new scheduled triggers will be skipped until it completes.
concurrency:
  group: ${{ github.workflow }}-merger
  cancel-in-progress: false # Let the current merging process finish

permissions:
  contents: write # To merge branches and delete branches
  pull-requests: write # To merge PRs and interact with them

jobs:
  automerge:
    runs-on: ubuntu-latest
    env:
      # --- CONFIGURATION ---
      GH_TOKEN: ${{ secrets.GITHUB_TOKEN }} # Provided by GitHub Actions
      BASE_BRANCH: 'master' # The branch PRs should target to be considered for merging
      MERGE_METHOD: 'SQUASH' # MERGE, SQUASH, or REBASE
      DELETE_BRANCH_AFTER_MERGE: 'true' # 'true' or 'false'
      # Optional: Only merge PRs with this label. Leave empty to disable.
      REQUIRED_LABEL: 'automerge' # e.g., 'ready-to-merge' or 'automerge'
      # --- END CONFIGURATION ---

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Required for gh cli to work properly with branches

      - name: Get Default Branch if BASE_BRANCH is not set (or to verify)
        if: env.BASE_BRANCH == '' # Or if you want to dynamically fetch it
        run: |
          DEFAULT_BRANCH=$(gh repo view --json defaultBranchRef --jq '.defaultBranchRef.name')
          echo "DEFAULT_BRANCH_NAME=${DEFAULT_BRANCH}" >> $GITHUB_ENV
          echo "Using default branch: $DEFAULT_BRANCH"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }} # gh cli needs token

      - name: Set Base Branch to Use
        run: |
          BRANCH_TO_USE="${{ env.BASE_BRANCH }}"
          if [ -z "$BRANCH_TO_USE" ]; then
            BRANCH_TO_USE="${{ env.DEFAULT_BRANCH_NAME }}"
          fi
          echo "BASE_BRANCH_EFFECTIVE=${BRANCH_TO_USE}" >> $GITHUB_ENV
          echo "Will process PRs targeting: ${BRANCH_TO_USE}"

      - name: Fetch Mergeable PRs
        id: get_prs
        run: |
          echo "Fetching PRs targeting ${{ env.BASE_BRANCH_EFFECTIVE }}..."
          
          # Special handling for Snyk PRs
          echo "Checking for Snyk PRs (branches starting with 'snyk-fix-')"
          
          # Get detailed PR data
          PR_DATA=$(gh pr list \
            --state open \
            --base "${{ env.BASE_BRANCH_EFFECTIVE }}" \
            --limit 100 \
            --json "number,title,headRefName,author,isDraft,mergeable,mergeStateStatus,reviewDecision,labels")
          
          echo "Example PR data:"
          echo "$PR_DATA" | jq -r 'limit(1; .[])' | jq .
          
          # Create the filter query based on conditions
          # Note: The example shows mergeable is "UNKNOWN" as string, not boolean
          JQ_FILTER="map(select(
            .isDraft == false and 
            (.mergeable == true or .mergeable == \"UNKNOWN\" or .mergeable == null)"
          
          # Add label filter if required
          if [ -n "${{ env.REQUIRED_LABEL }}" ]; then
            echo "Filtering for label: ${{ env.REQUIRED_LABEL }}"
            JQ_FILTER="$JQ_FILTER and (.labels | map(.name) | index(\"${{ env.REQUIRED_LABEL }}\") != null)"
          fi
          
          # Add Snyk detection filter - if detecting Snyk PRs, we want ONLY those
          JQ_FILTER="$JQ_FILTER and (
            (.headRefName | startswith(\"snyk-fix-\")) or 
            (.author.login == \"snyk-bot\") or
            (.title | startswith(\"[Snyk]\"))
          )"
          
          # Close the filter and extract numbers
          JQ_FILTER="$JQ_FILTER)) | map(.number)"
          
          echo "Using JQ filter: $JQ_FILTER"
          
          # Apply the filter
          PR_NUMBERS=$(echo "$PR_DATA" | jq -r "$JQ_FILTER | join(\" \")")
          
          # Output the results
          if [ -z "$PR_NUMBERS" ] || [ "$PR_NUMBERS" = "null" ]; then
            echo "No mergeable Snyk PRs found meeting criteria."
            echo "PR_NUMBERS_TO_MERGE=" >> $GITHUB_OUTPUT
          else
            echo "Found Snyk PRs to merge (numbers): $PR_NUMBERS"
            echo "PR_NUMBERS_TO_MERGE=$PR_NUMBERS" >> $GITHUB_OUTPUT
          fi
          
          # Debug - display counters to understand filtering better
          echo "Debug counts:"
          echo "Total open PRs: $(echo "$PR_DATA" | jq -r 'length')"
          echo "Non-draft PRs: $(echo "$PR_DATA" | jq -r 'map(select(.isDraft == false)) | length')"
          echo "Snyk PRs: $(echo "$PR_DATA" | jq -r 'map(select((.headRefName | startswith("snyk-fix-")) or (.author.login == "snyk-bot") or (.title | startswith("[Snyk]")))) | length')"
          echo "PRs with required label: $(echo "$PR_DATA" | jq -r 'map(select(.labels | map(.name) | index("${{ env.REQUIRED_LABEL }}") != null)) | length')"
          echo "Final filter result count: $(echo "$PR_DATA" | jq -r "$JQ_FILTER | length")"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Merge PRs Sequentially
        if: steps.get_prs.outputs.PR_NUMBERS_TO_MERGE != ''
        run: |
          echo "Attempting to merge PRs: ${{ steps.get_prs.outputs.PR_NUMBERS_TO_MERGE }}"
          
          # Build merge command arguments
          MERGE_ARGS=""
          if [ "${{ env.DELETE_BRANCH_AFTER_MERGE }}" == "true" ]; then
            MERGE_ARGS="$MERGE_ARGS --delete-branch"
          fi

          case "${{ env.MERGE_METHOD }}" in
            SQUASH)
              MERGE_ARGS="$MERGE_ARGS --squash"
              ;;
            REBASE)
              MERGE_ARGS="$MERGE_ARGS --rebase"
              ;;
            MERGE)
              MERGE_ARGS="$MERGE_ARGS --merge"
              ;;
            *)
              echo "Invalid MERGE_METHOD: ${{ env.MERGE_METHOD }}. Using default (merge commit)."
              MERGE_ARGS="$MERGE_ARGS --merge"
              ;;
          esac
          
          # Create a file to track merged and failed PRs
          echo "# Automerge Report $(date)" > merge_report.md
          echo "" >> merge_report.md
          echo "| PR # | Status | Title | Reason |" >> merge_report.md
          echo "|------|--------|-------|--------|" >> merge_report.md
          
          for pr_number in ${{ steps.get_prs.outputs.PR_NUMBERS_TO_MERGE }}; do
            echo "Attempting to merge PR #$pr_number with method: ${{ env.MERGE_METHOD }}"
            
            # Get PR details
            PR_DETAILS=$(gh pr view $pr_number --json number,title,headRefName,url)
            echo "PR details:"
            echo "$PR_DETAILS" | jq .
            
            TITLE=$(echo "$PR_DETAILS" | jq -r '.title')
            HEAD_BRANCH=$(echo "$PR_DETAILS" | jq -r '.headRefName')
            PR_URL=$(echo "$PR_DETAILS" | jq -r '.url')
            
            echo "Processing: #$pr_number - $TITLE ($HEAD_BRANCH)"
            echo "URL: $PR_URL"
            
            # First attempt: Try with current merge method
            echo "1️⃣ First attempt: Trying to merge with ${{ env.MERGE_METHOD }} method and admin flag..."
            if gh pr merge $pr_number $MERGE_ARGS --admin; then
              echo "✅ Successfully merged PR #$pr_number with ${{ env.MERGE_METHOD }} method"
              echo "| $pr_number | ✅ Success | $TITLE | Merged with ${{ env.MERGE_METHOD }} method |" >> merge_report.md
              sleep 5
              continue
            fi
            
            # Second attempt: Try with auto flag for simple conflicts
            echo "2️⃣ Second attempt: Trying with --auto flag for automatic conflict resolution..."
            if gh pr merge $pr_number $MERGE_ARGS --admin --auto; then
              echo "✅ Successfully merged PR #$pr_number with auto conflict resolution"
              echo "| $pr_number | ✅ Success | $TITLE | Auto-resolved conflicts |" >> merge_report.md
              sleep 5
              continue
            fi
            
            # Third attempt: If there's a required label, make sure it's added
            if [ -n "${{ env.REQUIRED_LABEL }}" ]; then
              echo "3️⃣ Third attempt: Adding label ${{ env.REQUIRED_LABEL }} and trying again..."
              gh pr edit $pr_number --add-label "${{ env.REQUIRED_LABEL }}"
              if gh pr merge $pr_number $MERGE_ARGS --admin --auto; then
                echo "✅ Successfully merged PR #$pr_number after adding label"
                echo "| $pr_number | ✅ Success | $TITLE | Added label and auto-resolved |" >> merge_report.md
                sleep 5
                continue
              fi
            fi
            
            # Fourth attempt: Try merge commit method as fallback
            if [ "${{ env.MERGE_METHOD }}" != "MERGE" ]; then
              echo "4️⃣ Fourth attempt: Falling back to merge commit method..."
              if gh pr merge $pr_number --merge --admin --auto; then
                echo "✅ Successfully merged PR #$pr_number with merge commit method"
                echo "| $pr_number | ✅ Success | $TITLE | Used merge commit method |" >> merge_report.md
                sleep 5
                continue
              fi
            fi
            
            # Final fallback: For very important security fixes, try force merge
            if [[ "$TITLE" == *"Security upgrade"* ]] || [[ "$TITLE" == *"security fix"* ]] || [[ "$TITLE" == *"vulnerability"* ]]; then
              echo "5️⃣ Final attempt: Adding security-fix label and trying one last time..."
              gh pr edit $pr_number --add-label "security-fix"
              if gh pr merge $pr_number --merge --admin --auto; then
                echo "✅ Successfully merged security fix PR #$pr_number with final attempt"
                echo "| $pr_number | ✅ Success | $TITLE | Force merged security fix |" >> merge_report.md
                sleep 5
                continue
              fi
            fi
            
            # If we got here, all merge attempts failed
            echo "❌ Failed to merge PR #$pr_number after multiple attempts."
            echo "| $pr_number | ❌ Failed | $TITLE | Could not resolve conflicts automatically |" >> merge_report.md
            
            # Record the merge failure reason
            ERROR_OUTPUT=$(gh pr merge $pr_number $MERGE_ARGS --admin 2>&1 || true)
            echo "Error: $ERROR_OUTPUT" >> merge_report.md
            echo "" >> merge_report.md
            echo "To resolve manually:" >> merge_report.md
            echo "\`\`\`" >> merge_report.md
            echo "gh pr checkout $pr_number && git fetch origin ${{ env.BASE_BRANCH_EFFECTIVE }} && git merge origin/${{ env.BASE_BRANCH_EFFECTIVE }}" >> merge_report.md
            echo "\`\`\`" >> merge_report.md
            
            # Wait between PRs
            echo "Waiting 5 seconds before processing the next PR..."
            sleep 5
          done
          
          echo "All queued PRs processed. Final report:"
          cat merge_report.md
          
          # Optional: Create an issue with the merge report
          if grep -q "Failed" merge_report.md; then
            echo "Creating issue with merge report for failed PRs..."
            gh issue create --title "Automerger Report: $(date +%Y-%m-%d)" --body-file merge_report.md --label "automerge-report"
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: No PRs to merge
        if: steps.get_prs.outputs.PR_NUMBERS_TO_MERGE == ''
        run: echo "No PRs met the criteria for merging at this time."
