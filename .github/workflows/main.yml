name: Sequential PR Automerger

on:
  workflow_dispatch: # Allows manual triggering
  schedule:
    - cron: '*/10 * * * *' # Runs every 10 minutes (reduced from every 1 minute to avoid rate limiting)

# Ensures only one instance of this workflow runs at a time for this group.
# If a run is in progress, new scheduled triggers will be skipped until it completes.
concurrency:
  group: ${{ github.workflow }}-merger
  cancel-in-progress: false # Let the current merging process finish

permissions:
  contents: write # To merge branches and delete branches
  pull-requests: write # To merge PRs and interact with them

jobs:
  automerge:
    runs-on: ubuntu-latest
    env:
      # --- CONFIGURATION ---
      GH_TOKEN: ${{ secrets.GITHUB_TOKEN }} # Provided by GitHub Actions
      BASE_BRANCH: 'master' # The branch PRs should target to be considered for merging
      MERGE_METHOD: 'SQUASH' # MERGE, SQUASH, or REBASE
      DELETE_BRANCH_AFTER_MERGE: 'true' # 'true' or 'false'
      # Optional: Only merge PRs with this label. Leave empty to disable.
      REQUIRED_LABEL: 'automerge' # e.g., 'ready-to-merge' or 'automerge'
      # --- END CONFIGURATION ---

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Required for gh cli to work properly with branches

      - name: Get Default Branch if BASE_BRANCH is not set (or to verify)
        if: env.BASE_BRANCH == '' # Or if you want to dynamically fetch it
        run: |
          DEFAULT_BRANCH=$(gh repo view --json defaultBranchRef --jq '.defaultBranchRef.name')
          echo "DEFAULT_BRANCH_NAME=${DEFAULT_BRANCH}" >> $GITHUB_ENV
          echo "Using default branch: $DEFAULT_BRANCH"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }} # gh cli needs token

      - name: Set Base Branch to Use
        run: |
          BRANCH_TO_USE="${{ env.BASE_BRANCH }}"
          if [ -z "$BRANCH_TO_USE" ]; then
            BRANCH_TO_USE="${{ env.DEFAULT_BRANCH_NAME }}"
          fi
          echo "BASE_BRANCH_EFFECTIVE=${BRANCH_TO_USE}" >> $GITHUB_ENV
          echo "Will process PRs targeting: ${BRANCH_TO_USE}"

      - name: Fetch Mergeable PRs
        id: get_prs
        run: |
          echo "Fetching PRs targeting ${{ env.BASE_BRANCH_EFFECTIVE }}..."
          
          # Special handling for Snyk PRs
          echo "Checking for Snyk PRs (branches starting with 'snyk-fix-')"
          
          # Get detailed PR data
          PR_DATA=$(gh pr list \
            --state open \
            --base "${{ env.BASE_BRANCH_EFFECTIVE }}" \
            --limit 100 \
            --json "number,title,headRefName,author,isDraft,mergeable,mergeStateStatus,reviewDecision,labels")
          
          echo "Found PRs data, now filtering..."
          
          # Debug - show some sample data
          echo "$PR_DATA" | jq -r 'limit(1; .[])' | jq .
          
          # Create the filter query based on conditions
          JQ_FILTER="map(select(
            .isDraft == false and 
            (.mergeable == true or .mergeable == null) and
            (.mergeStateStatus == \"CLEAN\" or .mergeStateStatus == \"HAS_HOOKS\" or .mergeStateStatus == null)"
          
          # Add label filter if required
          if [ -n "${{ env.REQUIRED_LABEL }}" ]; then
            echo "Filtering for label: ${{ env.REQUIRED_LABEL }}"
            JQ_FILTER="$JQ_FILTER and (.labels | map(.name) | index(\"${{ env.REQUIRED_LABEL }}\") != null)"
          fi
          
          # Add Snyk detection filter
          JQ_FILTER="$JQ_FILTER and (
            (.headRefName | startswith(\"snyk-fix-\")) or 
            (.author.login == \"snyk-bot\") or
            (.title | startswith(\"[Snyk]\"))
          )"
          
          # Close the filter and extract numbers
          JQ_FILTER="$JQ_FILTER)) | map(.number)"
          
          echo "Using JQ filter: $JQ_FILTER"
          
          # Apply the filter
          PR_NUMBERS=$(echo "$PR_DATA" | jq -r "$JQ_FILTER | join(\" \")")
          
          # Output the results
          if [ -z "$PR_NUMBERS" ] || [ "$PR_NUMBERS" = "null" ]; then
            echo "No mergeable Snyk PRs found meeting criteria."
            echo "PR_NUMBERS_TO_MERGE=" >> $GITHUB_OUTPUT
          else
            echo "Found Snyk PRs to merge (numbers): $PR_NUMBERS"
            echo "PR_NUMBERS_TO_MERGE=$PR_NUMBERS" >> $GITHUB_OUTPUT
          fi
          
          # Debug - display counters to understand filtering better
          echo "Debug counts:"
          echo "Total open PRs: $(echo "$PR_DATA" | jq -r 'length')"
          echo "Non-draft PRs: $(echo "$PR_DATA" | jq -r 'map(select(.isDraft == false)) | length')"
          echo "Mergeable PRs: $(echo "$PR_DATA" | jq -r 'map(select(.mergeable == true or .mergeable == null)) | length')"
          echo "Clean/ready PRs: $(echo "$PR_DATA" | jq -r 'map(select(.mergeStateStatus == "CLEAN" or .mergeStateStatus == "HAS_HOOKS" or .mergeStateStatus == null)) | length')"
          echo "Snyk PRs: $(echo "$PR_DATA" | jq -r 'map(select((.headRefName | startswith("snyk-fix-")) or (.author.login == "snyk-bot") or (.title | startswith("[Snyk]")))) | length')"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Merge PRs Sequentially
        if: steps.get_prs.outputs.PR_NUMBERS_TO_MERGE != ''
        run: |
          echo "Attempting to merge PRs: ${{ steps.get_prs.outputs.PR_NUMBERS_TO_MERGE }}"
          
          # Build merge command arguments
          MERGE_ARGS=""
          if [ "${{ env.DELETE_BRANCH_AFTER_MERGE }}" == "true" ]; then
            MERGE_ARGS="$MERGE_ARGS --delete-branch"
          fi

          case "${{ env.MERGE_METHOD }}" in
            SQUASH)
              MERGE_ARGS="$MERGE_ARGS --squash"
              ;;
            REBASE)
              MERGE_ARGS="$MERGE_ARGS --rebase"
              ;;
            MERGE)
              MERGE_ARGS="$MERGE_ARGS --merge"
              ;;
            *)
              echo "Invalid MERGE_METHOD: ${{ env.MERGE_METHOD }}. Using default (merge commit)."
              MERGE_ARGS="$MERGE_ARGS --merge"
              ;;
          esac
          
          for pr_number in ${{ steps.get_prs.outputs.PR_NUMBERS_TO_MERGE }}; do
            echo "Attempting to merge PR #$pr_number with method: ${{ env.MERGE_METHOD }}"
            
            # Get PR details
            PR_DETAILS=$(gh pr view $pr_number --json number,title,headRefName,url,mergeable,mergeStateStatus)
            echo "PR details: $PR_DETAILS"
            
            TITLE=$(echo "$PR_DETAILS" | jq -r '.title')
            HEAD_BRANCH=$(echo "$PR_DETAILS" | jq -r '.headRefName')
            PR_URL=$(echo "$PR_DETAILS" | jq -r '.url')
            
            echo "Processing: #$pr_number - $TITLE ($HEAD_BRANCH)"
            echo "URL: $PR_URL"
            
            # Special handling for Snyk PRs - always try to merge regardless of status
            # Snyk PRs are usually security fixes that should be prioritized
            if [[ "$HEAD_BRANCH" == snyk-fix-* ]] || [[ "$TITLE" == \[Snyk\]* ]]; then
              echo "This is a Snyk security fix PR - proceeding with merge"
              
              # For Snyk PRs, we want to be aggressive about merging security fixes
              if gh pr merge $pr_number $MERGE_ARGS --admin; then
                echo "✅ Successfully merged Snyk PR #$pr_number"
              else 
                echo "❌ Failed to merge Snyk PR #$pr_number. Adding required label and retrying..."
                
                # If there's a required label, try adding it and merging again
                if [ -n "${{ env.REQUIRED_LABEL }}" ]; then
                  gh pr edit $pr_number --add-label "${{ env.REQUIRED_LABEL }}"
                  
                  if gh pr merge $pr_number $MERGE_ARGS --admin; then
                    echo "✅ Successfully merged Snyk PR #$pr_number after adding label"
                  else
                    echo "❌ Failed to merge Snyk PR #$pr_number even after adding label."
                  fi
                fi
              fi
            else
              # For non-Snyk PRs, verify mergeable status
              MERGEABLE=$(echo "$PR_DETAILS" | jq -r '.mergeable')
              MERGE_STATE=$(echo "$PR_DETAILS" | jq -r '.mergeStateStatus')
              
              if [ "$MERGEABLE" == "true" ] || [ "$MERGE_STATE" == "CLEAN" ] || [ "$MERGE_STATE" == "HAS_HOOKS" ]; then
                if gh pr merge $pr_number $MERGE_ARGS --admin; then
                  echo "✅ Successfully merged PR #$pr_number"
                else
                  echo "❌ Failed to merge PR #$pr_number. Continuing to the next PR."
                fi
              else
                echo "PR #$pr_number is not mergeable (mergeable=$MERGEABLE, state=$MERGE_STATE). Skipping."
              fi
            fi
            
            # Wait to allow CI to catch up (CI might be needed for subsequent PRs)
            echo "Waiting 10 seconds before processing the next PR..."
            sleep 10
          done
          echo "All queued PRs processed."
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: No PRs to merge
        if: steps.get_prs.outputs.PR_NUMBERS_TO_MERGE == ''
        run: echo "No PRs met the criteria for merging at this time."
